/*
  Falak compiler - WebAssembly text file (Wat) code generator.
  
  Authors:
  Javier Pascal Flores          A01375925
  Diego Palmerin Bonada         A01747290
  Hector Ivan Aguirre Arteaga   A01169628

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Text;
using System.Collections.Generic;

namespace Falak
{
    class WatVisitor
    {
        public static IList<int> AsCodePoints(string str)
        {
            var result = new List<int>(str.Length);
            for (var i = 0; i < str.Length; i++)
            {
                if (str[i] == '\\')
                {
                    switch (str[i + 1])
                    {
                        case 'n':
                            result.Add(10);
                            i += 1;
                            break;
                        case 'r':
                            result.Add(13);
                            i += 1;
                            break;
                        case 't':
                            result.Add(9);
                            i += 1;
                            break;
                        case '\\':
                            result.Add(92);
                            i += 1;
                            break;
                        case '\'':
                            result.Add(39);
                            i += 1;
                            break;
                        case '"':
                            result.Add(34);
                            i += 1;
                            break;
                        case 'u':
                            result.Add(Convert.ToInt16(str.Substring(i + 2, 6), 16));
                            i += 7;
                            break;
                    }
                }
                else
                {
                    result.Add(char.ConvertToUtf32(str, i));
                    if (char.IsHighSurrogate(str, i))
                    {
                        i++;
                    }
                }
            }
            return result;
        }

        int labelCounter = 0;

        public string GenerateLabel()
        {
            return string.Format("${0:00000}", labelCounter++);
        }

        string breakTarget;
        string inFunction;
        HashSet<string> globals;
        IDictionary<string, FunctionRegister> functions;

        //-----------------------------------------------------------

        public WatVisitor(HashSet<string> variablesTable, IDictionary<string, FunctionRegister> functionsTable)
        {
            this.globals = variablesTable;
            this.functions = functionsTable;
        }

        public string Visit(Program node)
        {
            var globalsStr = "";
            foreach (var name in globals)
            {
                globalsStr += $"  (global ${name} (mut i32) (i32.const 0))\n";
            }
            return ";; WebAssembly text format code generated by "
                + "the falak compiler.\n\n"
                + "(module\n"
                + "  (import \"falak\" \"printi\" (func $printi (param i32) (result i32)))\n"
                + "  (import \"falak\" \"printc\" (func $printc (param i32) (result i32)))\n"
                + "  (import \"falak\" \"prints\" (func $prints (param i32) (result i32)))\n"
                + "  (import \"falak\" \"println\" (func $println (result i32)))\n"
                + "  (import \"falak\" \"readi\" (func $readi (result i32)))\n"
                + "  (import \"falak\" \"reads\" (func $reads (result i32)))\n"
                + "  (import \"falak\" \"new\" (func $new (param i32) (result i32)))\n"
                + "  (import \"falak\" \"size\" (func $size (param i32) (result i32)))\n"
                + "  (import \"falak\" \"add\" (func $add (param i32 i32) (result i32)))\n"
                + "  (import \"falak\" \"get\" (func $get (param i32 i32) (result i32)))\n"
                + "  (import \"falak\" \"set\" (func $set (param i32 i32 i32) (result i32)))\n"
                + globalsStr
                + "  (global $_xor1 (mut i32) (i32.const 0))\n"
                + "  (global $_xor2 (mut i32) (i32.const 0))\n"
                + "  (func\n"
                + "    (export \"start\")\n"
                + "    (result i32)\n\n"
                + "    call $main\n"
                + "    drop\n"
                + "    i32.const 0\n"
                + "  )\n"
                + ""
                + Visit((dynamic)node[0])
                + ")\n";
        }

        public string Visit(While node)
        {
            var parent = breakTarget;
            breakTarget = GenerateLabel();
            var label2 = GenerateLabel();
            var sb = new StringBuilder();
            sb.Append($"  block {breakTarget}\n");
            sb.Append($"    loop {label2}\n");
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("    i32.eqz\n");
            sb.Append($"    br_if {breakTarget}\n");
            sb.Append(Visit((dynamic)node[1]));
            sb.Append($"    br {label2}\n");
            sb.Append("    end\n");
            sb.Append("  end\n");
            breakTarget = parent;
            return sb.ToString();
        }

        public string Visit(Do node)
        {
            var parent = breakTarget;
            breakTarget = GenerateLabel();
            var label2 = GenerateLabel();
            var sb = new StringBuilder();
            sb.Append($"  block {breakTarget}\n");
            sb.Append($"    loop {label2}\n");
            sb.Append(Visit((dynamic)node[0]));
            sb.Append(Visit((dynamic)node[1]));
            sb.Append("      i32.eqz\n");
            sb.Append($"      br_if {breakTarget}\n");
            sb.Append($"      br {label2}\n");
            sb.Append("    end\n");
            sb.Append("  end\n");
            breakTarget = parent;
            return sb.ToString();
        }

        public string Visit(Return node)
        {
            return VisitChildren(node)
                + "    return\n";
        }

        public string Visit(Function node)
        {
            inFunction = node.AnchorToken.Lexeme;
            var sb = new StringBuilder();
            sb.Append($"  (func ${node.AnchorToken.Lexeme}\n");
            foreach (var arg in node[0])
            {
                sb.Append($"    (param ${arg.AnchorToken.Lexeme} i32)\n");
            }
            sb.Append("    (result i32)\n\n");
            sb.Append($"    (local $_temp i32)\n");
            foreach (var variable in node[1])
            {
                sb.Append($"    (local ${variable.AnchorToken.Lexeme} i32)\n");
            }
            sb.Append("\n" + Visit((dynamic)node[2]));
            sb.Append("    i32.const 0\n");
            sb.Append("  )\n");
            return sb.ToString();
        }

        public string Visit(FunCall node)
        {
            var sb = new StringBuilder();
            sb.Append(VisitChildren(node));
            sb.Append($"    call ${node.AnchorToken.Lexeme}\n");
            return sb.ToString();
        }

        public string Visit(String node)
        {
            var codes = AsCodePoints(node.AnchorToken.Lexeme.Substring(1, node.AnchorToken.Lexeme.Length - 2));
            var sb = new StringBuilder();
            sb.Append(
                   "    i32.const 0\n"
                 + "    call $new\n"
                 + "    local.set $_temp\n\n"
                 );
            for (var i = 0; i <= codes.Count; i++)
            {
                sb.Append("    local.get $_temp\n");
            }
            foreach (var code in codes)
            {
                sb.Append(
                      $"    i32.const {code}\n"
                    + "    call $add\n"
                    + "    drop\n"
                );
            }
            return sb.ToString();
        }

        public string Visit(Character node)
        {
            var codes = AsCodePoints(node.AnchorToken.Lexeme.Substring(1, node.AnchorToken.Lexeme.Length - 2));
            return $"    i32.const {codes[0]}\n";
        }

        public string Visit(Array node)
        {
            var sb = new StringBuilder();
            sb.Append(
                   "    i32.const 0\n"
                 + "    call $new\n"
                 + "    local.set $_temp\n\n"
                 );
            for (var i = 0; i <= node.ChildrenLength; i++)
            {
                sb.Append("    local.get $_temp\n");
            }
            foreach (var value in node)
            {
                sb.Append(Visit((dynamic)value)
                    + "    call $add\n"
                    + "    drop\n"
                );
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        public string Visit(DeclarationList node)
        {
            var sb = new StringBuilder();
            foreach (var declaration in node)
            {
                sb.Append(Visit((dynamic)declaration));
            }
            return sb.ToString();
        }

        public string Visit(VarDef node)
        {
            var sb = new StringBuilder();
            foreach (var identifier in node[0])
            {
                sb.Append($"  (local {identifier.AnchorToken.Lexeme} i32)\n");
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        public string Visit(StatementList node)
        {
            var sb = new StringBuilder();
            foreach (var curr in node) {
                sb.Append(Visit((dynamic) curr));
                if (curr is FunCall) {
                    sb.Append("    drop\n");
                }
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        public string Visit(Assignment node)
        {
            string nameSpace = functions[inFunction].value.Contains(node.AnchorToken.Lexeme) ? "local" : "global";
            return Visit((dynamic)node[0])
                + $"    {nameSpace}.set ${node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(If node)
        {
            var elif = "";
            if (node[2].ChildrenLength > 0)
            {
                elif = "    else\n" + Visit((dynamic)node[2]);
            }
            else
            {
                elif += "    else\n";
            }
            if (node[3].ChildrenLength > 0)
            {
                elif += Visit((dynamic)node[3][0]);
            }
            for (var i = 0; i < node[2].ChildrenLength; i++)
            {
                elif += "    end\n";
            }
            return Visit((dynamic)node[0])
                + "    if\n"
                + Visit((dynamic)node[1])
                + elif
                + "    end\n";
        }

        public string Visit(ElseIf node)
        {
            return "  " + Visit((dynamic)node[0])
                 + "      if\n"
                 + "  " + Visit((dynamic)node[1])
                 + "      else\n";
        }

        public string Visit(Break node)
        {
            return $"    br {breakTarget}\n";
        }

        //-----------------------------------------------------------
        public string Visit(Identifier node)
        {
            string nameSpace = functions[inFunction].value.Contains(node.AnchorToken.Lexeme) ? "local" : "global";
            return $"    {nameSpace}.get ${node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(IntLiteral node)
        {
            return $"    i32.const {node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(True node)
        {
            return "    i32.const 1\n";
        }

        //-----------------------------------------------------------
        public string Visit(False node)
        {
            return "    i32.const 0\n";
        }

        //-----------------------------------------------------------
        public string Visit(Neg node)
        {
            return "    i32.const 0\n"
                + Visit((dynamic)node[0])
                + "    i32.sub\n";
        }

        public string Visit(Not node)
        {
            return Visit((dynamic)node[0])
                + "    i32.eqz\n";
        }

        //-----------------------------------------------------------
        public string Visit(And node)
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("    if (result i32)\n");
            sb.Append(Visit((dynamic)node[1]));
            sb.Append("      i32.eqz\n");
            sb.Append("      i32.eqz\n");
            sb.Append("    else\n");
            sb.Append("      i32.const 0\n");
            sb.Append("    end\n");
            return sb.ToString();
        }

        //-----------------------------------------------------------
        public string Visit(Or node)
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic)node[0]));
            sb.Append("    if (result i32)\n");
            sb.Append("      i32.const 1\n");
            sb.Append("    else\n");
            sb.Append(Visit((dynamic)node[1]));
            sb.Append("      i32.eqz\n");
            sb.Append("      i32.eqz\n");
            sb.Append("    end\n");
            return sb.ToString();
        }

        public string Visit(Inc node)
        {
            string nameSpace = functions[inFunction].value.Contains(node.AnchorToken.Lexeme) ? "local" : "global";
            return $"    {nameSpace}.get ${node.AnchorToken.Lexeme}\n"
                + "    i32.const 1\n"
                + "    i32.add\n"
                + $"    {nameSpace}.set ${node.AnchorToken.Lexeme}\n";
        }

        public string Visit(Dec node)
        {
            string nameSpace = functions[inFunction].value.Contains(node.AnchorToken.Lexeme) ? "local" : "global";
            return $"    {nameSpace}.get ${node.AnchorToken.Lexeme}\n"
                + "    i32.const 1\n"
                + "    i32.sub\n"
                + $"    {nameSpace}.set ${node.AnchorToken.Lexeme}\n";
        }

        //-----------------------------------------------------------
        public string Visit(Plus node)
        {
            if (node.ChildrenLength == 1) { return Visit((dynamic)node[0]); }
            return VisitBinaryOperator("i32.add", node);
        }

        public string Visit(Minus node)
        {
            if (node.ChildrenLength == 1)
            {
                return "   i32.const 0\n"
                    + Visit((dynamic)node[0])
                    + "    i32.sub\n";
            }
            return VisitBinaryOperator("i32.sub", node);
        }

        //-----------------------------------------------------------
        public string Visit(Mul node)
        {
            return VisitBinaryOperator("i32.mul", node);
        }

        public string Visit(Div node)
        {
            return VisitBinaryOperator("i32.div_s", node);
        }

        public string Visit(Remainder node)
        {
            return VisitBinaryOperator("i32.rem_s", node);
        }

        public string Visit(Equals node)
        {
            return VisitBinaryOperator("i32.eq", node);
        }

        public string Visit(NotEquals node)
        {
            return VisitBinaryOperator("i32.ne", node);
        }

        public string Visit(Less node)
        {
            return VisitBinaryOperator("i32.lt_s", node);
        }

        public string Visit(LessEqual node)
        {
            return VisitBinaryOperator("i32.le_s", node);
        }

        public string Visit(More node)
        {
            return VisitBinaryOperator("i32.gt_s", node);
        }

        public string Visit(MoreEqual node)
        {
            return VisitBinaryOperator("i32.ge_s", node);
        }

        public string Visit(BitOr node)
        {
            return Visit((dynamic) node[0])
                + "    i32.eqz\n"
                + Visit((dynamic) node[1])
                + "    i32.eqz\n"
                + "    i32.ne";
        }

        //-----------------------------------------------------------
        string VisitChildren(Node node)
        {
            var sb = new StringBuilder();
            foreach (var n in node)
            {
                sb.Append(Visit((dynamic)n));
            }
            return sb.ToString();
        }

        string Visit(Node node)
        {
            var sb = new StringBuilder();
            foreach (var n in node)
            {
                sb.Append(Visit((dynamic)n));
            }
            return sb.ToString();
        }

        //-----------------------------------------------------------
        string VisitBinaryOperator(string op, Node node)
        {
            return Visit((dynamic) node[0])
                + Visit((dynamic) node[1])
                + $"    {op}\n";
        }
    }
}
